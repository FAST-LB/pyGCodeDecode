---
title: 'pyGCodeDecode: A Python package for GCode simulation for Material Extrusion Processes.'
tags:
  - Python
  - GCode
  - Simulation
  - Fused Filament Deoposition
  - Fused Filament Fabrication
  - Material Extrusion
  - Additive Manufacturing
  - 3D Printing
  - Process Simulation
authors:
  - name: Jonathan Knirsch
    orcid: 0000-0000-0000-0000
    equal-contrib: false
    affiliation: 1
  - name: Felix Frölich
    equal-contrib: false
    affiliation: 1
  - name: Lukas Hof
    equal-contrib: false
    affiliation: 1
  - name: Luise Kärger
    equal-contrib: false
    affiliation: 1
affiliations:
 - name: Karlsruhe Institute of Technology (KIT), Insitute of Vehicle System Technology, Germany
   index: 1
date: 21 August 2023
bibliography: paper.bib

---

# Summary

The Machine instructions for the Fused Filament Fabrication (FFF) Process are usually provided as GCode, generated by a variety of slicer software. A 3D Model is sliced into many layers, on which toolpaths for walls, infill, support and other structures are generated. The toolpaths are defined by a list in GCode with target points in space and the amount of extruded material. Additionally process parameters like temperatures, velocitys or cooling fan speeds are often set and changed throughout the print according to the GCode. The complex interactions between the high number of process parameters either stemming from the slicer software or the printer firmware require a detailed interpretation of the GCode coupled with a recreation of the firmware trajectory planning. Even though many printers share the same firmware flavour, printing results and time vary a lot. Especially influential are machine limits such as maximum printing velocity, acceleration and jerk. A good understanding and modeling of the trajectory mechanics is key to further improving slicing algorithms and printer hardware as well as improving process simulations such as thermo-mechanical modeling and micro-scale fluid simulations.

![Comparison between simulated acceleration.\label{fig:acc_comp}](comparison.png){width=60%}

`pyGcd` is a Python package for GCode interpretation and FFF Firmware simulation.
Its class-based structure and separation of modules enable extensive modifications and additions. The built-in GCode parser translates the line by line information into a state class, which contains all possible information from the GCode as well as the GCode history and user-set firmware default values supporting printer presets. In the following step the trajectory modeling connects all states by planning accelerating, constant speed and deccelerating segments. This is achieved by simply solving the equations of the surface area under the trapezoidal velocity profile for the missing parameters.
$$
S = S_{acc} + S_{const} + S_{dec}
$$
The sum of all segment distances is the total planner block distance.

![Trapezoidal Velocity Profile.\label{fig:trapezoid}](trapezoid_profile.svg){width=40%}

Equations for the individual distances for linear acceleration, constant velocity and deceleration.
$$
S_{acc} = \frac{1}{2} (v_{const} - v_{0}) t_{acc}
$$
$$
S_{const} =  v_{const}t_{const}
$$
$$
S_{dec} = \frac{1}{2} (v_{1} - v_{const}) t_{dec}
$$

In the simplest case, the planner can fit a complete trapez to the boundary conditions. Since real life GCode is often finely discretized, especially in curved surfaces, $v_{const}$ or even $v_{1}$ can never be reached with given acceleration settings. In these cases, the parameters which are being solved for change accordingly and the velocity profile is truncated.
The junction velocities in corners are calculated with the junction deviation model based on the grbl/Marlin firmware implementation. All segments of a single move are stored together with its enclosing states in a planner block class. The package is designed to easily apply modifications to either the interpretation and trajectory modeling as well as overwriting the simulation inputs, e.g. states or acceleration modeling, to create parameter studys without much effort.
`pyGCD` provides many examples ranging from simple GCode analysis with plots using Mayavi or Matplotlib to an Abaqus AM Modeler input file generator. The package is designed to be used by researchers and users to gain a better understanding of the time dependant process variables and study their resulting material properties in greater detail than otherwise possible.

# Acknowledgements

We acknowledge contributions from * for this project.

# References
[@grbl]
[@marlin]
[@marlin_doc]

<!-- GRBL Firmware GitHub Repository: [https://github.com/grbl/grbl](https://github.com/grbl/grbl)

Marlin Firmware GCode Documentation: [https://marlinfw.org/meta/gcode/](https://marlinfw.org/meta/gcode/)

Marlin Firmware GitHub Repository: [https://github.com/MarlinFirmware/Marlin](https://github.com/MarlinFirmware/Marlin) -->

<!-- http://blog.kyneticcnc.com/2018/10/computing-junction-deviation-for-marlin.html
https://onehossshay.wordpress.com/2011/09/24/improving_grbl_cornering_algorithm/
https://reprap.org/forum/read.php?1,739819 -->
