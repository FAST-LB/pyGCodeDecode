---
title: 'pyGCodeDecode: A Python package for GCode simulation in material extrusion processes'
tags:
  - Python
  - GCode
  - Simulation
  - Fused Filament Deposition
  - Fused Filament Fabrication
  - Material Extrusion
  - Additive Manufacturing
  - 3D Printing
  - Machine Code
  - Firmware
  - FFF
  - FDM
  - Process Simulation
authors:
  - name: Jonathan Knirsch
    orcid: 0009-0008-8663-8721
    equal-contrib: false
    affiliation: 1
  - name: Felix Frölich
    orcid: 0000-0002-2575-4752
    equal-contrib: false
    affiliation: 1
  - name: Lukas Hof
    orcid: 0009-0000-4931-2409
    equal-contrib: false
    affiliation: 1
  - name: Luise Kärger
    orcid: 0000-0002-6534-6518
    equal-contrib: false
    affiliation: 1
affiliations:
 - name: Karlsruhe Institute of Technology (KIT), Institute of Vehicle System Technology, Germany
   index: 1
date: 21 August 2023
bibliography: paper.bib

---

# Summary

The Machine instructions for material extrusion processes (MEX), such as the fused filament fabrication (FFF) process, are typically provided as GCode, which can be generated by a variety of slicer programs. The 3D model of the part is sliced into multiple layers and a tool path is created for each according to the parameters for infill, perimeters supports and other structures. [@Gibson:2021] The exported GCode consists of a list of commands specifying target points in space for the tool as well as the amount of material to be extruded. Additionally, process parameters such as temperatures, velocities or cooling fan speeds are set and changed during printing according to the GCode. 
However, the GCode itself does not accurately reflect the eventual printing process. It is interpreted by the printer's firmware that plans the trajectory taking into account the machine's limitations. Especially the maximum printing speed, acceleration and jerk have a significant influence on the path velocities. Extrusion velocity has an influence on mechanical properties like tensile strength or surface roughness. [@Altan:2018] Firmware settings like jerk and acceleration also affect surface roughness of printed parts. [Yadav:2023] Higher extrusion velocitys also contribute to reduced per cent cristallinity in PLA. [@Luzanin:2019] 
Although many printers use similar firmware, print results and print times can vary widely when running the same GCode path on different machines. Setting a higher target printing velocity on a machine with insufficient acceleration capabilities will lead to a large difference between target and actual printing velocity as illustrated in \autoref{fig:acc_comp}. This can lead to unexpected behavior and a slower print than anticipated. Many slicers will predict the progression of the print but these predictions might deviate significantly from the actual process. Simulating the GCode allows the user to identify and locate affected areas to improve the slicing. A good understanding and accurate modeling of trajectory behaviors can contribute significantly to the improvement of slicing algorithms and printer hardware through the virtual evaluation of GCode. In addition, modeling of those behaviors enables more accurate virtual replication of the process through process simulations such as thermomechanical modeling and small-scale fluid simulations.
<span style="font-variant:small-caps;">pyGCD</span> is a Python package for GCode interpretation and MEX Firmware simulation. The package was developed to enable researchers and users to better understand time-dependent process variables and enable a more accurate study of the printing process. Its source code is available at LINK TO THE REPO and a release on <span style="font-variant:small-caps;">PyPI</span> should be available soon.

![Comparison between simulated acceleration.\label{fig:acc_comp}](comparison.png){width=80%}

# Methodology

<span style="font-variant:small-caps;">pyGCD's</span> class-based structure and separation of modules allow for simple and extensive modifications or additions. Its GCode parser transfers individual commands into a state class containing every command's parameters as well as the GCode history and user-set firmware parameters. Most printers use a trapezoidal velocity profile for each move which is constrained by its entry, target and exit velocities, as well as the maximum acceleration. While the maximum acceleration and target velocity are configured in the firmware settings and the GCode respectively, the entry and exit velocities are calculated using a variety of different cornering algorithms. Usually some limited instantaneous change in velocity is allowed, while taking the change in travel direction into account. Smaller changes in direction generally require less reduction in travel speed. <span style="font-variant:small-caps;">pyGCD</span> provides models of cornering algorithms for several firmwares. They are implemented as classes according to the respective documentation. E.g. <span style="font-variant:small-caps;">Marlin</span> classic jerk, <span style="font-variant:small-caps;">Marlin</span> junction deviation and Klipper. The junction velocities are calculated using the selected cornering algorithm. Then the trajectory modeling connects all states by planning accelerating, constant velocity, and decelerating segments matching the junction velocities. This is achieved by solving the equations of the surface area under the trapezoidal velocity profile shown in \autoref{fig:trapezoid} for the missing parameters.

![Trapezoidal velocity profile.\label{fig:trapezoid}](trapezoid_profile.svg){width=60%}

Using
$$
S = S_{\mathrm{acc}} + S_{\mathrm{const}} + S_{\mathrm{dec}}
$$
the sum of all segment distances is the total planner block distance $S$. The individual distances for linear acceleration $S_{\mathrm{acc}}$, constant velocity $S_{\mathrm{const}}$ and deceleration $S_{\mathrm{dec}}$ are given by
$$
S_{\mathrm{acc}} = \frac{1}{2} (v_{\mathrm{const}} + v_{\mathrm{0}}) t_{\mathrm{acc}}
$$
$$
S_{\mathrm{const}} =  v_{\mathrm{const}} t_{\mathrm{const}}
$$
$$
S_{\mathrm{dec}} = \frac{1}{2} (v_{\mathrm{1}} + v_{\mathrm{const}}) t_{\mathrm{dec}}.
$$
With the initial velocity $v_{\mathrm{0}}$, the target velocity $v_{\mathrm{const}}$ and ending velocity $v_{\mathrm{1}}$ of the planner block given and using a constant printing acceleration $a$. One can solve for the acceleration time $t_{\mathrm{acc}}$, the constant velocity time $t_{\mathrm{const}}$ and the deceleration time $t_{\mathrm{dec}}$ to construct the trapezoid.
In the simplest case, the planner can fit a complete trapezoid to the boundary conditions. Since real life GCode is often finely discretized, especially for curved surfaces. Also, $v_{\mathrm{const}}$ or $v_{\mathrm{1}}$ cannot be reached with the given acceleration settings. In these cases, the parameters which are being solved for change accordingly and the velocity profile is truncated. <!-- Verstehe den letzte Satz leider nicht. - LH -->
The junction velocities in corners are calculated with the junction deviation model based on the <span style="font-variant:small-caps;">grbl/Marlin/...</span> firmware implementation [@grbl]  [@marlin] [@marlin_doc]  [@klipper_doc].
All segments of a single move are stored together with its enclosing states in a planner block class. The package is designed to allow for modifications to both the interpretation and trajectory modeling as well as overwriting the GCode simulation inputs, e.g. states or acceleration modeling, to create parameter studies without much effort.

<span style="font-variant:small-caps;">pyGCD</span> provides many examples for simple GCode analysis with 3D color plots of the trajectory and velocity using <span style="font-variant:small-caps;">PyVista</span> or visualizing the axis velocities and positions in <span style="font-variant:small-caps;">Matplotlib</span>. As well as an input file generator for the "AM Modeler" plugin for the finite element analysis software <span style="font-variant:small-caps;">Abaqus</span> to use the real process conditions in a process simulation.

# Validation

<span style="font-variant:small-caps;">pyGCD</span> has been validated with experiments on a FFF printer running a <span style="font-variant:small-caps;">Marlin</span> derived firmware by Prusa (Prusa Mini). In order to measure the accuracy of the simulation, a test GCode containing a simple repeating triangular path has been chosen to emulate a printed layer. After each layer, a layer change is simulated by moving the Z-Axis.The time was measured for each layer using a camera by analyzing the footage. By changing the jerk setting in the firmware through a GCode command, this test pattern can validate several different calculations done in the simulation. In \autoref{fig:validation} the layer duration is plotted over different jerk values ranging from one to 30, which is equal to the target velocity set in the test GCode.

![Validation of the simulation by measuring layer duration.\label{fig:validation}](plot.svg){width=60%}

For the chosen case the layer duration is highly dependant on the set jerk values. For jerk values equal to the target printing velocity, the calculated time is expected to approach a constant velocity solution calculated analytically. Therefore, the acceleration and cornering algorithms have no influence on the print time of a layer. For jerk values close to zero, the printer is expected to slow almost to a full stop for each turn in the path. This result is similar to the simplest velocity trapezoid where entry and exit velocities are zero. The layer time for this edge case was also  validated by analytical calculations. The comparison to experimental data for jerk values between these edge cases shows that the implemented cornering algorithm models the Prusa Mini firmware behavior well.

# Acknowledgements

We acknowledge the Baden-Württemberg Ministry of Science, Research and the Arts (MWK) for the funding of the projects "Efficient process design for the processing of polylactide (PLA) in fused filament fabrication (F³FastSim)" and "Basics of a remanufacturing process chain for functional, hybridized polymer components to increase reusability and optimize resource utilization (Restore)" as part of the InnovationCampus Future Mobility (ICM) in which this work was carried out, as well as the German Research Foundation (DFG) for funding the professorship of Prof. Kärger's Heisenberg professorship.

# References
