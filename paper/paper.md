---
title: 'pyGCodeDecode: A Python package for GCode simulation in material extrusion processes'
tags:
  - Python
  - GCode
  - Simulation
  - Fused Filament Deposition
  - Fused Filament Fabrication
  - Material Extrusion
  - Additive Manufacturing
  - 3D Printing
  - Machine Code
  - Firmware
  - FFF
  - FDM
  - Process Simulation
authors:
  - name: Jonathan Knirsch
    orcid: 0009-0008-8663-8721
    equal-contrib: false
    affiliation: 1
  - name: Felix Frölich
    orcid: 0000-0002-2575-4752
    equal-contrib: false
    affiliation: 1
  - name: Lukas Hof
    orcid: 0009-0000-4931-2409
    equal-contrib: false
    affiliation: 1
  - name: Luise Kärger
    equal-contrib: false
    affiliation: 1
affiliations:
 - name: Karlsruhe Institute of Technology (KIT), Institute of Vehicle System Technology, Germany
   index: 1
date: 21 August 2023
bibliography: paper.bib

---

# Summary

The Machine instructions for material extrusion processes (MEX), such as the fused filament fabrication (FFF) process, are typically provided as GCode, which can be generated by a variety of slicer programs. The 3D model of the part is sliced into multiple layers and a tool path is created for each according to the parameters for infill, perimeters supports and other structures. The exported GCode consists of a list of commands specifying target points in space for the tool as well as the amount of material to be extruded. Additionally, process parameters such as temperatures, velocities or cooling fan speeds are set and changed during printing according to the GCode.
However, the GCode itself does not accurately reflect the eventual printing process. It is interpreted by the printer's firmware that plans the trajectory taking into account the machine's limitations. Especially the maximum printing speed, acceleration and jerk, have a significantly influence the real trajectory.
Many slicers will predict the progression of the print but these predictions will often deviate significantly from the actual process. Although many printers use the similar firmware, print results and print times can vary widely when running the same GCode path on different machines. Setting a higher target printing velocity on a machine with insufficient acceleration capabilities will lead to a large difference between target and actual printing velocity as illustrated in \autoref{fig:acc_comp}. A good understanding and accurate modeling of trajectory mechanics can contribute significantly to the improvement of slicing algorithms and printer hardware. In addition, modeling of those mechanics enables more accurate virtual replication of the process through process simulations such as thermomechanical modeling and small-scale fluid simulations.
<!-- Mir ist nicht ganz klar, was "trajectory mechanics" sind. Das mechanische System wird ja durch pyGCD nicht modelliert sondern nur das "trajectory planning" abgebildet. Meinst du die Modelle, für die pyGCD der Input sein soll? - LH -->
<!-- Die Verbindung wie pyGCD zur Verbesserung der Slicer und Hardware führt ist mir noch nicht ganz klar. Einen einzelnen Druck kann ich natürlich besser planen. - LH  -->
<span style="font-variant:small-caps;">pyGCD</span> is a Python package for GCode interpretation and MEX Firmware simulation. The package was developed to enable researchers and users to better understand time-dependent process variables and enable a more accurate study of the printing process. Its source code is available at LINK TO THE REPO and a release on <span style="font-variant:small-caps;">PyPI</span> should be available soon.

![Comparison between simulated acceleration.\label{fig:acc_comp}](comparison.png){width=80%}

# Methodology

<span style="font-variant:small-caps;">pyGCD's</span> class-based structure and separation of modules allow for simple and extensive modifications or additions. Its GCode parser transfers individual commands into a state class containing every command's parameters as well as the GCode history and user-set firmware parameters. Most printers use a trapezoidal velocity profile for each move which is constrained by its initial, target and final velocities, as well as the maximum acceleration. While the maximum acceleration and target velocity are configured in the firmware settings and the GCode respectively, the initial and final velocities are calculated using a variety of different cornering algorithms. Usually some limited instantaneous change in velocity is allowed if the change in direction is small. Smaller changes in direction generally require less reduction in travel speed. <span style="font-variant:small-caps;">pyGCD</span> provides models of cornering algorithms for several firmwares. They are implemented as classes according to the respective documentation. E.g. <span style="font-variant:small-caps;">Marlin</span> classic jerk, <span style="font-variant:small-caps;">Marlin</span> junction deviation and Klipper. The junction velocities are calculated using the selected cornering algorithm. Then the trajectory modeling connects all states by planning accelerating, constant velocity, and decelerating segments matching the junction velocities. This is achieved by solving the equations of the surface area under the trapezoidal velocity profile shown in \autoref{fig:trapezoid} for the missing parameters.

![Trapezoidal velocity profile.\label{fig:trapezoid}](trapezoid_profile.svg){width=60%}

<!-- In diesem Absatz könnte man sich dann auf die Abbildung von dir beziehen. Man könnte überlegen. Ob man das auch an einem kleinen Beispiel zeigt. Oder ist das zu aufwendig und umfangreich? -->
Using
$$
S = S_{\mathrm{acc}} + S_{\mathrm{const}} + S_{\mathrm{dec}}
$$
the sum of all segment distances is the total planner block distance $S$. The individual distances for linear acceleration $S_{\mathrm{acc}}$, constant velocity $S_{\mathrm{const}}$ and deceleration $S_{\mathrm{dec}}$ are given by
$$
S_{\mathrm{acc}} = \frac{1}{2} (v_{\mathrm{const}} + v_{\mathrm{0}}) t_{\mathrm{acc}}
$$
$$
S_{\mathrm{const}} =  v_{\mathrm{const}} t_{\mathrm{const}}
$$
$$
S_{\mathrm{dec}} = \frac{1}{2} (v_{\mathrm{1}} + v_{\mathrm{const}}) t_{\mathrm{dec}}.
$$
With the initial velocity $v_{\mathrm{0}}$, the target velocity $v_{\mathrm{const}}$ and ending velocity $v_{\mathrm{1}}$ of the planner block given and using a constant printing acceleration $a$. One can solve for the acceleration time $t_{\mathrm{acc}}$, the constant velocity time $t_{\mathrm{const}}$ and the deceleration time $t_{\mathrm{dec}}$ to construct the trapezoid.
In the simplest case, the planner can fit a complete trapezoid to the boundary conditions. Since real life GCode is often finely discretized, especially for curved surfaces. Also, $v_{\mathrm{const}}$ or $v_{\mathrm{1}}$ cannot be reached with the given acceleration settings. In these cases, the parameters which are being solved for change accordingly and the velocity profile is truncated. <!-- Verstehe den letzte Satz leider nicht. - LH -->
The junction velocities in corners are calculated with the junction deviation model based on the <span style="font-variant:small-caps;">grbl/Marlin</span> firmware implementation.
<!-- Man könnte überlegen diese noch mit einer kleinen Abbildung und Formel näher zu erklären. Das würde ich aber erst machen wenn wir am ende denken das ist notwendig -->
All segments of a single move are stored together with its enclosing states in a planner block class. The package is designed to allow for modifications to both the interpretation and trajectory modeling as well as overwriting the simulation inputs, e.g. states or acceleration modeling, to create parameter studies without much effort.<!-- Ich verstehe den letzten Satz nicht. - LH -->

<!-- \autoref{fig:general} depicts the general structure and dependencies of the plannerblocks to its states and segments.  -->
<!-- ![Overview of the planner block class structure.\label{fig:general}](general.svg){width=60%} -->

<!-- vielleicht dieses bild detaillierter um den programmablauf zu verdeutlichen, wird dann aber viel und ggfs unübersichtlicher.. -->
<span style="font-variant:small-caps;">pyGCD</span> provides many examples for simple GCode analysis with 3D color plots of the trajectory and velocity using <span style="font-variant:small-caps;">Mayavi</span> or visualizing the axis velocities and positions in <span style="font-variant:small-caps;">Matplotlib</span>. As well as an input file generator for the "AM Modeler" plugin for the finite element analysis software <span style="font-variant:small-caps;">Abaqus</span> to use the real process conditions in a process simulation.

# Validation

<span style="font-variant:small-caps;">pyGCD</span> has been validated with experiments on a FFF printer running a <span style="font-variant:small-caps;">Marlin</span> derived firmware by Prusa (Prusa Mini). In order to measure the accuracy of the simulation, a test GCode containing a simple repeating triangular path has been chosen to emulate a printed layer. After each layer, a layer change is simulated by moving the Z-Axis.The time was measured for each layer using a camera by analyzing the footage. By changing the jerk setting in the firmware through a GCode command, this test pattern can validate several different calculations done in the simulation. In \autoref{fig:validation} the layer duration is plotted over different jerk values ranging from one to 30, which is equal to the target velocity set in the test GCode.

![Validation of the simulation by measuring layer duration.\label{fig:validation}](plot.svg){width=60%}

For the chosen case the layer duration is highly dependant on the set jerk values. For jerk values equal to the target printing velocity, the solution is expected to approach a constant velocity calculated analytically for the test path distance. Therefore, the acceleration and cornering algorithms have no influence on the print time of a layer. For small jerk values close to zero, the printer is expected to slow almost to a full stop for each turn in the path. This result is similar to the simplest velocity trapezoid where initial and final velocities are zero. The layer time for this edge case was also  validated by analytical calculations. The comparison to experimental data for jerk values between these edge cases shows that the implemented cornering algorithm models the Prusa Mini firmware behavior well.

# Acknowledgements

We acknowledge the Baden-Württemberg Ministry of Science, Research and the Arts (MWK) for the funding of the projects "Efficient process design for the processing of polylactide (PLA) in fused filament fabrication (F³FastSim)" and "Basics of a remanufacturing process chain for functional, hybridized polymer components to increase reusability and optimize resource utilization (Restore)" as part of the InnovationCampus Future Mobility (ICM) in which this work was carried out, as well as the German Research Foundation (DFG) for funding the professorship of Prof. Kärger's Heisenberg professorship.

# References

[@grbl]
[@marlin]
[@marlin_doc]

<!-- GRBL Firmware GitHub Repository: [https://github.com/grbl/grbl](https://github.com/grbl/grbl)

Marlin Firmware GCode Documentation: [https://marlinfw.org/meta/gcode/](https://marlinfw.org/meta/gcode/)

Marlin Firmware GitHub Repository: [https://github.com/MarlinFirmware/Marlin](https://github.com/MarlinFirmware/Marlin) -->

<!-- http://blog.kyneticcnc.com/2018/10/computing-junction-deviation-for-marlin.html
https://onehossshay.wordpress.com/2011/09/24/improving_grbl_cornering_algorithm/
https://reprap.org/forum/read.php?1,739819 -->
